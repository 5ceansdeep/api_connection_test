/* tslint:disable */
/* eslint-disable */
/**
 * 인천대학교 공지사항 API
 * 인천대학교 공지사항 앱 백엔드 API 문서
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ApiResponseBoolean {
    'success'?: boolean;
    'message'?: string;
    'data'?: boolean;
    'timestamp'?: string;
}
export interface ApiResponseDetailResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: DetailResponse;
    'timestamp'?: string;
}
export interface ApiResponseFindIdResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: FindIdResponse;
    'timestamp'?: string;
}
export interface ApiResponseListResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: Array<Response>;
    'timestamp'?: string;
}
export interface ApiResponseLoginResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: LoginResponse;
    'timestamp'?: string;
}
export interface ApiResponseLong {
    'success'?: boolean;
    'message'?: string;
    'data'?: number;
    'timestamp'?: string;
}
export interface ApiResponsePageResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: PageResponse;
    'timestamp'?: string;
}
export interface ApiResponseResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: Response;
    'timestamp'?: string;
}
export interface ApiResponseString {
    'success'?: boolean;
    'message'?: string;
    'data'?: string;
    'timestamp'?: string;
}
export interface ApiResponseUserResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: UserResponse;
    'timestamp'?: string;
}
export interface ApiResponseVoid {
    'success'?: boolean;
    'message'?: string;
    'data'?: object;
    'timestamp'?: string;
}
export interface ChangePasswordRequest {
    'currentPassword': string;
    'newPassword': string;
    'confirmPassword': string;
}
export interface CreateRequest {
    'noticeId'?: number;
    'memo'?: string;
}
export interface DeleteAccountRequest {
    'password': string;
}
export interface DetailResponse {
    'id'?: number;
    'title'?: string;
    'content'?: string;
    'url'?: string;
    'externalId'?: string;
    'category'?: Response;
    'author'?: string;
    'publishedAt'?: string;
    'viewCount'?: number;
    'isImportant'?: boolean;
    'isPinned'?: boolean;
    'attachments'?: string;
    'isBookmarked'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface FindIdRequest {
    'name': string;
    'studentId': string;
}
export interface FindIdResponse {
    'maskedEmail'?: string;
    'message'?: string;
}
export interface ForgotPasswordRequest {
    'email': string;
}
export interface LoginRequest {
    'email': string;
    'password': string;
    'fcmToken'?: string;
}
export interface LoginResponse {
    'accessToken'?: string;
    'refreshToken'?: string;
    'tokenType'?: string;
    'expiresIn'?: number;
    'user'?: UserResponse;
}
export interface PageResponse {
    'totalPages'?: number;
    'totalElements'?: number;
    'first'?: boolean;
    'size'?: number;
    'content'?: Array<Response>;
    'number'?: number;
    'sort'?: SortObject;
    'numberOfElements'?: number;
    'pageable'?: PageableObject;
    'last'?: boolean;
    'empty'?: boolean;
}
export interface PageableObject {
    'offset'?: number;
    'sort'?: SortObject;
    'pageNumber'?: number;
    'pageSize'?: number;
    'paged'?: boolean;
    'unpaged'?: boolean;
}
export interface RefreshTokenRequest {
    'refreshToken': string;
}
export interface ResetPasswordRequest {
    'token': string;
    'newPassword': string;
    'confirmPassword': string;
}
export interface Response {
    'id'?: number;
    'studentId'?: string;
    'email'?: string;
    'name'?: string;
    'role'?: string;
    'isActive'?: boolean;
    'darkMode'?: boolean;
    'systemNotificationEnabled'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface SaveRequest {
    'keyword'?: string;
}
export interface SignUpRequest {
    'studentId': string;
    'email': string;
    'password': string;
    'name': string;
}
export interface SortObject {
    'empty'?: boolean;
    'unsorted'?: boolean;
    'sorted'?: boolean;
}
export interface SubscribeRequest {
    'categoryId': number;
    'notificationEnabled'?: boolean;
}
export interface UpdateFcmTokenRequest {
    'fcmToken': string;
}
export interface UpdateNotificationRequest {
    'notificationEnabled': boolean;
}
export interface UpdateProfileRequest {
    'name': string;
    'email'?: string;
}
export interface UpdateRequest {
    'memo'?: string;
}
export interface UpdateSettingsRequest {
    'darkMode'?: boolean;
    'systemNotificationEnabled'?: boolean;
}
export interface UserResponse {
    'id'?: number;
    'studentId'?: string;
    'email'?: string;
    'name'?: string;
    'role'?: string;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
         * @summary 비밀번호 변경
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/api/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
         * @summary 북마크 생성
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark: async (createRequest: CreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('createBookmark', 'createRequest', createRequest)
            const localVarPath = `/api/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
         * @summary 회원 탈퇴
         * @param {DeleteAccountRequest} deleteAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (deleteAccountRequest: DeleteAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAccountRequest' is not null or undefined
            assertParamExists('deleteAccount', 'deleteAccountRequest', deleteAccountRequest)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 모든 최근 검색어를 삭제합니다.
         * @summary 모든 최근 검색어 삭제
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllRecentSearches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 저장한 북마크를 삭제합니다.
         * @summary 북마크 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBookmark', 'id', id)
            const localVarPath = `/api/bookmarks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 최근 검색어를 삭제합니다.
         * @summary 최근 검색어 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecentSearch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRecentSearch', 'id', id)
            const localVarPath = `/api/search/recent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
         * @summary 아이디 찾기
         * @param {FindIdRequest} findIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findId: async (findIdRequest: FindIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findIdRequest' is not null or undefined
            assertParamExists('findId', 'findIdRequest', findIdRequest)
            const localVarPath = `/api/auth/find-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 비밀번호 재설정 링크를 이메일로 발송합니다.
         * @summary 비밀번호 찾기
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordRequest: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordRequest', forgotPasswordRequest)
            const localVarPath = `/api/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 활성 상태인 카테고리만 조회합니다.
         * @summary 활성 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 알림이 활성화된 구독 카테고리만 조회합니다.
         * @summary 활성 구독 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/preferences/categories/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
         * @summary 전체 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 공지사항을 페이징하여 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 전체 공지사항 목록 조회
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllNotices: async (page?: number, size?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 북마크의 상세 정보를 조회합니다.
         * @summary 북마크 상세 조회
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBookmark', 'id', id)
            const localVarPath = `/api/bookmarks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 저장한 북마크의 총 개수를 조회합니다.
         * @summary 북마크 개수 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarks/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
         * @summary 특정 카테고리 조회
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryByCode: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getCategoryByCode', 'code', code)
            const localVarPath = `/api/categories/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
         * @summary 북마크 목록 조회
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyBookmarks: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 현재 로그인한 사용자의 정보를 조회합니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 구독한 모든 카테고리 목록을 조회합니다.
         * @summary 구독 카테고리 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/preferences/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID로 특정 공지사항의 상세 정보를 조회합니다.
         * @summary 공지사항 상세 조회
         * @param {number} id 공지사항 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNoticeById', 'id', id)
            const localVarPath = `/api/notices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 카테고리의 공지사항 목록을 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 카테고리별 공지사항 조회
         * @param {string} categoryCode 카테고리 코드
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticesByCategory: async (categoryCode: string, page?: number, size?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryCode' is not null or undefined
            assertParamExists('getNoticesByCategory', 'categoryCode', categoryCode)
            const localVarPath = `/api/notices/category/{categoryCode}`
                .replace(`{${"categoryCode"}}`, encodeURIComponent(String(categoryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
         * @summary 최근 검색어 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentSearches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자가 구독한 카테고리의 공지사항만 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 구독 공지사항 조회
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedNotices: async (page?: number, size?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notices/subscribed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 공지사항이 북마크되어 있는지 확인합니다.
         * @summary 북마크 여부 확인
         * @param {number} noticeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isBookmarked: async (noticeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeId' is not null or undefined
            assertParamExists('isBookmarked', 'noticeId', noticeId)
            const localVarPath = `/api/bookmarks/check/{noticeId}`
                .replace(`{${"noticeId"}}`, encodeURIComponent(String(noticeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 카테고리를 구독하고 있는지 확인합니다.
         * @summary 구독 여부 확인
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isSubscribed: async (categoryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('isSubscribed', 'categoryId', categoryId)
            const localVarPath = `/api/preferences/categories/{categoryId}/subscribed`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일과 비밀번호로 로그인하여 JWT 토큰을 발급받습니다.
         * @summary 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그아웃 처리를 합니다. 클라이언트에서 토큰을 삭제해야 합니다.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 리프레시 토큰으로 새로운 액세스 토큰을 발급받습니다.
         * @summary 토큰 갱신
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일 인증 메일을 다시 발송합니다.
         * @summary 인증 메일 재발송
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('resendVerificationEmail', 'email', email)
            const localVarPath = `/api/auth/resend-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일로 받은 토큰으로 새로운 비밀번호를 설정합니다.
         * @summary 비밀번호 재설정
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/api/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
         * @summary 최근 검색어 저장
         * @param {SaveRequest} saveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRecentSearch: async (saveRequest: SaveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveRequest' is not null or undefined
            assertParamExists('saveRecentSearch', 'saveRequest', saveRequest)
            const localVarPath = `/api/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 제목 또는 내용에 키워드가 포함된 공지사항을 검색합니다.
         * @summary 공지사항 검색
         * @param {string} keyword 검색 키워드
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNotices: async (keyword: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('searchNotices', 'keyword', keyword)
            const localVarPath = `/api/notices/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 인천대학교 이메일로 회원가입을 진행합니다. 가입 후 이메일 인증이 필요합니다.
         * @summary 회원가입
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('signUp', 'signUpRequest', signUpRequest)
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
         * @summary 카테고리 구독
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCategory: async (subscribeRequest: SubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequest' is not null or undefined
            assertParamExists('subscribeCategory', 'subscribeRequest', subscribeRequest)
            const localVarPath = `/api/preferences/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 카테고리 구독을 취소합니다.
         * @summary 구독 취소
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeCategory: async (categoryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('unsubscribeCategory', 'categoryId', categoryId)
            const localVarPath = `/api/preferences/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 저장한 북마크의 메모를 수정합니다.
         * @summary 북마크 메모 수정
         * @param {number} id 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkMemo: async (id: number, updateRequest: UpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBookmarkMemo', 'id', id)
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updateBookmarkMemo', 'updateRequest', updateRequest)
            const localVarPath = `/api/bookmarks/{id}/memo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
         * @summary FCM 토큰 업데이트
         * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFcmToken: async (updateFcmTokenRequest: UpdateFcmTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFcmTokenRequest' is not null or undefined
            assertParamExists('updateFcmToken', 'updateFcmTokenRequest', updateFcmTokenRequest)
            const localVarPath = `/api/users/fcm-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFcmTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
         * @summary 알림 설정 변경
         * @param {number} categoryId 
         * @param {UpdateNotificationRequest} updateNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateNotification', 'categoryId', categoryId)
            // verify required parameter 'updateNotificationRequest' is not null or undefined
            assertParamExists('updateNotification', 'updateNotificationRequest', updateNotificationRequest)
            const localVarPath = `/api/preferences/categories/{categoryId}/notification`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 이름 등 프로필 정보를 수정합니다.
         * @summary 프로필 수정
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (updateProfileRequest: UpdateProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileRequest' is not null or undefined
            assertParamExists('updateProfile', 'updateProfileRequest', updateProfileRequest)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
         * @summary 사용자 설정 수정
         * @param {UpdateSettingsRequest} updateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings: async (updateSettingsRequest: UpdateSettingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSettingsRequest' is not null or undefined
            assertParamExists('updateSettings', 'updateSettingsRequest', updateSettingsRequest)
            const localVarPath = `/api/users/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 회원가입 시 발송된 이메일의 인증 링크로 이메일을 인증합니다.
         * @summary 이메일 인증
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmail', 'token', token)
            const localVarPath = `/api/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
         * @summary 비밀번호 변경
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
         * @summary 북마크 생성
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmark(createRequest: CreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmark(createRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
         * @summary 회원 탈퇴
         * @param {DeleteAccountRequest} deleteAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(deleteAccountRequest: DeleteAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(deleteAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 모든 최근 검색어를 삭제합니다.
         * @summary 모든 최근 검색어 삭제
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllRecentSearches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllRecentSearches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAllRecentSearches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 저장한 북마크를 삭제합니다.
         * @summary 북마크 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 최근 검색어를 삭제합니다.
         * @summary 최근 검색어 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecentSearch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecentSearch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteRecentSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
         * @summary 아이디 찾기
         * @param {FindIdRequest} findIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findId(findIdRequest: FindIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseFindIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findId(findIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 비밀번호 재설정 링크를 이메일로 발송합니다.
         * @summary 비밀번호 찾기
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 활성 상태인 카테고리만 조회합니다.
         * @summary 활성 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getActiveCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 알림이 활성화된 구독 카테고리만 조회합니다.
         * @summary 활성 구독 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivePreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivePreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getActivePreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
         * @summary 전체 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 공지사항을 페이징하여 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 전체 공지사항 목록 조회
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllNotices(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllNotices(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllNotices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 북마크의 상세 정보를 조회합니다.
         * @summary 북마크 상세 조회
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmark(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmark(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBookmark']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 저장한 북마크의 총 개수를 조회합니다.
         * @summary 북마크 개수 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmarkCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseLong>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarkCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBookmarkCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
         * @summary 특정 카테고리 조회
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryByCode(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryByCode(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getCategoryByCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
         * @summary 북마크 목록 조회
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyBookmarks(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyBookmarks(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyBookmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 현재 로그인한 사용자의 정보를 조회합니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 구독한 모든 카테고리 목록을 조회합니다.
         * @summary 구독 카테고리 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMyPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID로 특정 공지사항의 상세 정보를 조회합니다.
         * @summary 공지사항 상세 조회
         * @param {number} id 공지사항 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNoticeById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoticeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNoticeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 카테고리의 공지사항 목록을 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 카테고리별 공지사항 조회
         * @param {string} categoryCode 카테고리 코드
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNoticesByCategory(categoryCode: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoticesByCategory(categoryCode, page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNoticesByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
         * @summary 최근 검색어 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentSearches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentSearches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRecentSearches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자가 구독한 카테고리의 공지사항만 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 구독 공지사항 조회
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribedNotices(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribedNotices(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSubscribedNotices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 공지사항이 북마크되어 있는지 확인합니다.
         * @summary 북마크 여부 확인
         * @param {number} noticeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isBookmarked(noticeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isBookmarked(noticeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.isBookmarked']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 카테고리를 구독하고 있는지 확인합니다.
         * @summary 구독 여부 확인
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isSubscribed(categoryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseBoolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isSubscribed(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.isSubscribed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일과 비밀번호로 로그인하여 JWT 토큰을 발급받습니다.
         * @summary 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그아웃 처리를 합니다. 클라이언트에서 토큰을 삭제해야 합니다.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 리프레시 토큰으로 새로운 액세스 토큰을 발급받습니다.
         * @summary 토큰 갱신
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseString>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일 인증 메일을 다시 발송합니다.
         * @summary 인증 메일 재발송
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVerificationEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerificationEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resendVerificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일로 받은 토큰으로 새로운 비밀번호를 설정합니다.
         * @summary 비밀번호 재설정
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
         * @summary 최근 검색어 저장
         * @param {SaveRequest} saveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRecentSearch(saveRequest: SaveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRecentSearch(saveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.saveRecentSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 제목 또는 내용에 키워드가 포함된 공지사항을 검색합니다.
         * @summary 공지사항 검색
         * @param {string} keyword 검색 키워드
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchNotices(keyword: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponsePageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchNotices(keyword, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.searchNotices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 인천대학교 이메일로 회원가입을 진행합니다. 가입 후 이메일 인증이 필요합니다.
         * @summary 회원가입
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
         * @summary 카테고리 구독
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeCategory(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeCategory(subscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.subscribeCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 카테고리 구독을 취소합니다.
         * @summary 구독 취소
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeCategory(categoryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsubscribeCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 저장한 북마크의 메모를 수정합니다.
         * @summary 북마크 메모 수정
         * @param {number} id 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBookmarkMemo(id: number, updateRequest: UpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBookmarkMemo(id, updateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateBookmarkMemo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
         * @summary FCM 토큰 업데이트
         * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFcmToken(updateFcmTokenRequest: UpdateFcmTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFcmToken(updateFcmTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateFcmToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
         * @summary 알림 설정 변경
         * @param {number} categoryId 
         * @param {UpdateNotificationRequest} updateNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(categoryId, updateNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 이름 등 프로필 정보를 수정합니다.
         * @summary 프로필 수정
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(updateProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
         * @summary 사용자 설정 수정
         * @param {UpdateSettingsRequest} updateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSettings(updateSettingsRequest: UpdateSettingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSettings(updateSettingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 회원가입 시 발송된 이메일의 인증 링크로 이메일을 인증합니다.
         * @summary 이메일 인증
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseVoid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
         * @summary 비밀번호 변경
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
         * @summary 북마크 생성
         * @param {CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark(createRequest: CreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.createBookmark(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
         * @summary 회원 탈퇴
         * @param {DeleteAccountRequest} deleteAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(deleteAccountRequest: DeleteAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.deleteAccount(deleteAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 모든 최근 검색어를 삭제합니다.
         * @summary 모든 최근 검색어 삭제
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllRecentSearches(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.deleteAllRecentSearches(options).then((request) => request(axios, basePath));
        },
        /**
         * 저장한 북마크를 삭제합니다.
         * @summary 북마크 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmark(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.deleteBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 최근 검색어를 삭제합니다.
         * @summary 최근 검색어 삭제
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecentSearch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.deleteRecentSearch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
         * @summary 아이디 찾기
         * @param {FindIdRequest} findIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findId(findIdRequest: FindIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseFindIdResponse> {
            return localVarFp.findId(findIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 비밀번호 재설정 링크를 이메일로 발송합니다.
         * @summary 비밀번호 찾기
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.forgotPassword(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 활성 상태인 카테고리만 조회합니다.
         * @summary 활성 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCategories(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getActiveCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 알림이 활성화된 구독 카테고리만 조회합니다.
         * @summary 활성 구독 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivePreferences(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getActivePreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
         * @summary 전체 카테고리 목록 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getAllCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 공지사항을 페이징하여 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 전체 공지사항 목록 조회
         * @param {number} [page] 페이지 번호 (0부터 시작)
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllNotices(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.getAllNotices(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 북마크의 상세 정보를 조회합니다.
         * @summary 북마크 상세 조회
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.getBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 저장한 북마크의 총 개수를 조회합니다.
         * @summary 북마크 개수 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkCount(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseLong> {
            return localVarFp.getBookmarkCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
         * @summary 특정 카테고리 조회
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryByCode(code: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.getCategoryByCode(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
         * @summary 북마크 목록 조회
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyBookmarks(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.getMyBookmarks(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 현재 로그인한 사용자의 정보를 조회합니다.
         * @summary 내 정보 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.getMyInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 구독한 모든 카테고리 목록을 조회합니다.
         * @summary 구독 카테고리 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPreferences(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getMyPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * ID로 특정 공지사항의 상세 정보를 조회합니다.
         * @summary 공지사항 상세 조회
         * @param {number} id 공지사항 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseDetailResponse> {
            return localVarFp.getNoticeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 카테고리의 공지사항 목록을 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 카테고리별 공지사항 조회
         * @param {string} categoryCode 카테고리 코드
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticesByCategory(categoryCode: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.getNoticesByCategory(categoryCode, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
         * @summary 최근 검색어 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentSearches(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListResponse> {
            return localVarFp.getRecentSearches(options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자가 구독한 카테고리의 공지사항만 조회합니다. 정렬 방식을 선택할 수 있습니다.
         * @summary 구독 공지사항 조회
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedNotices(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.getSubscribedNotices(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 공지사항이 북마크되어 있는지 확인합니다.
         * @summary 북마크 여부 확인
         * @param {number} noticeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isBookmarked(noticeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseBoolean> {
            return localVarFp.isBookmarked(noticeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 카테고리를 구독하고 있는지 확인합니다.
         * @summary 구독 여부 확인
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isSubscribed(categoryId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseBoolean> {
            return localVarFp.isSubscribed(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일과 비밀번호로 로그인하여 JWT 토큰을 발급받습니다.
         * @summary 로그인
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseLoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그아웃 처리를 합니다. 클라이언트에서 토큰을 삭제해야 합니다.
         * @summary 로그아웃
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 리프레시 토큰으로 새로운 액세스 토큰을 발급받습니다.
         * @summary 토큰 갱신
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseString> {
            return localVarFp.refreshToken(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일 인증 메일을 다시 발송합니다.
         * @summary 인증 메일 재발송
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerificationEmail(email: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.resendVerificationEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일로 받은 토큰으로 새로운 비밀번호를 설정합니다.
         * @summary 비밀번호 재설정
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.resetPassword(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
         * @summary 최근 검색어 저장
         * @param {SaveRequest} saveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRecentSearch(saveRequest: SaveRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.saveRecentSearch(saveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 제목 또는 내용에 키워드가 포함된 공지사항을 검색합니다.
         * @summary 공지사항 검색
         * @param {string} keyword 검색 키워드
         * @param {number} [page] 페이지 번호
         * @param {number} [size] 페이지당 항목 수
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNotices(keyword: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponsePageResponse> {
            return localVarFp.searchNotices(keyword, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 인천대학교 이메일로 회원가입을 진행합니다. 가입 후 이메일 인증이 필요합니다.
         * @summary 회원가입
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseUserResponse> {
            return localVarFp.signUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
         * @summary 카테고리 구독
         * @param {SubscribeRequest} subscribeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCategory(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.subscribeCategory(subscribeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 카테고리 구독을 취소합니다.
         * @summary 구독 취소
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeCategory(categoryId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.unsubscribeCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 저장한 북마크의 메모를 수정합니다.
         * @summary 북마크 메모 수정
         * @param {number} id 
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkMemo(id: number, updateRequest: UpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateBookmarkMemo(id, updateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
         * @summary FCM 토큰 업데이트
         * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFcmToken(updateFcmTokenRequest: UpdateFcmTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.updateFcmToken(updateFcmTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
         * @summary 알림 설정 변경
         * @param {number} categoryId 
         * @param {UpdateNotificationRequest} updateNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateNotification(categoryId, updateNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 이름 등 프로필 정보를 수정합니다.
         * @summary 프로필 수정
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateProfile(updateProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
         * @summary 사용자 설정 수정
         * @param {UpdateSettingsRequest} updateSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(updateSettingsRequest: UpdateSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseResponse> {
            return localVarFp.updateSettings(updateSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 회원가입 시 발송된 이메일의 인증 링크로 이메일을 인증합니다.
         * @summary 이메일 인증
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseVoid> {
            return localVarFp.verifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 현재 비밀번호 확인 후 새로운 비밀번호로 변경합니다.
     * @summary 비밀번호 변경
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 공지사항을 북마크에 저장합니다. 선택적으로 메모를 추가할 수 있습니다.
     * @summary 북마크 생성
     * @param {CreateRequest} createRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBookmark(createRequest: CreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBookmark(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 회원 탈퇴를 처리합니다. 모든 사용자 데이터가 삭제됩니다.
     * @summary 회원 탈퇴
     * @param {DeleteAccountRequest} deleteAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAccount(deleteAccountRequest: DeleteAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAccount(deleteAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 모든 최근 검색어를 삭제합니다.
     * @summary 모든 최근 검색어 삭제
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAllRecentSearches(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAllRecentSearches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 저장한 북마크를 삭제합니다.
     * @summary 북마크 삭제
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteBookmark(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 최근 검색어를 삭제합니다.
     * @summary 최근 검색어 삭제
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRecentSearch(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteRecentSearch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이름과 학번으로 아이디(이메일)를 찾습니다. 마스킹된 이메일과 함께 전체 이메일이 발송됩니다.
     * @summary 아이디 찾기
     * @param {FindIdRequest} findIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findId(findIdRequest: FindIdRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findId(findIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 비밀번호 재설정 링크를 이메일로 발송합니다.
     * @summary 비밀번호 찾기
     * @param {ForgotPasswordRequest} forgotPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forgotPassword(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 활성 상태인 카테고리만 조회합니다.
     * @summary 활성 카테고리 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActiveCategories(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActiveCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 알림이 활성화된 구독 카테고리만 조회합니다.
     * @summary 활성 구독 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActivePreferences(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActivePreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 카테고리의 목록을 조회합니다. 각 카테고리의 공지사항 개수도 함께 반환됩니다.
     * @summary 전체 카테고리 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllCategories(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 공지사항을 페이징하여 조회합니다. 정렬 방식을 선택할 수 있습니다.
     * @summary 전체 공지사항 목록 조회
     * @param {number} [page] 페이지 번호 (0부터 시작)
     * @param {number} [size] 페이지당 항목 수
     * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllNotices(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllNotices(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 북마크의 상세 정보를 조회합니다.
     * @summary 북마크 상세 조회
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBookmark(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 저장한 북마크의 총 개수를 조회합니다.
     * @summary 북마크 개수 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBookmarkCount(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBookmarkCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 카테고리 코드로 특정 카테고리 정보를 조회합니다.
     * @summary 특정 카테고리 조회
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategoryByCode(code: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCategoryByCode(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 저장한 북마크 목록을 페이징하여 조회합니다.
     * @summary 북마크 목록 조회
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyBookmarks(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyBookmarks(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 현재 로그인한 사용자의 정보를 조회합니다.
     * @summary 내 정보 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyInfo(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 구독한 모든 카테고리 목록을 조회합니다.
     * @summary 구독 카테고리 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyPreferences(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMyPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID로 특정 공지사항의 상세 정보를 조회합니다.
     * @summary 공지사항 상세 조회
     * @param {number} id 공지사항 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNoticeById(id: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNoticeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 카테고리의 공지사항 목록을 조회합니다. 정렬 방식을 선택할 수 있습니다.
     * @summary 카테고리별 공지사항 조회
     * @param {string} categoryCode 카테고리 코드
     * @param {number} [page] 페이지 번호
     * @param {number} [size] 페이지당 항목 수
     * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNoticesByCategory(categoryCode: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNoticesByCategory(categoryCode, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 최근 검색어 목록을 조회합니다. 최대 5개, 최신순으로 반환됩니다.
     * @summary 최근 검색어 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRecentSearches(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRecentSearches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자가 구독한 카테고리의 공지사항만 조회합니다. 정렬 방식을 선택할 수 있습니다.
     * @summary 구독 공지사항 조회
     * @param {number} [page] 페이지 번호
     * @param {number} [size] 페이지당 항목 수
     * @param {string} [sort] 정렬 방식 (latest: 최신순, viewCount: 조회순)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSubscribedNotices(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSubscribedNotices(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 공지사항이 북마크되어 있는지 확인합니다.
     * @summary 북마크 여부 확인
     * @param {number} noticeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public isBookmarked(noticeId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isBookmarked(noticeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 카테고리를 구독하고 있는지 확인합니다.
     * @summary 구독 여부 확인
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public isSubscribed(categoryId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isSubscribed(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일과 비밀번호로 로그인하여 JWT 토큰을 발급받습니다.
     * @summary 로그인
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그아웃 처리를 합니다. 클라이언트에서 토큰을 삭제해야 합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 리프레시 토큰으로 새로운 액세스 토큰을 발급받습니다.
     * @summary 토큰 갱신
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshToken(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일 인증 메일을 다시 발송합니다.
     * @summary 인증 메일 재발송
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendVerificationEmail(email: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resendVerificationEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일로 받은 토큰으로 새로운 비밀번호를 설정합니다.
     * @summary 비밀번호 재설정
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetPassword(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 검색한 키워드를 최근 검색어에 저장합니다. 최대 5개까지 저장되며, 중복 키워드는 검색 시각이 갱신됩니다.
     * @summary 최근 검색어 저장
     * @param {SaveRequest} saveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public saveRecentSearch(saveRequest: SaveRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveRecentSearch(saveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 제목 또는 내용에 키워드가 포함된 공지사항을 검색합니다.
     * @summary 공지사항 검색
     * @param {string} keyword 검색 키워드
     * @param {number} [page] 페이지 번호
     * @param {number} [size] 페이지당 항목 수
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchNotices(keyword: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchNotices(keyword, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 인천대학교 이메일로 회원가입을 진행합니다. 가입 후 이메일 인증이 필요합니다.
     * @summary 회원가입
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 카테고리를 구독하여 해당 카테고리의 공지사항 알림을 받을 수 있습니다.
     * @summary 카테고리 구독
     * @param {SubscribeRequest} subscribeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public subscribeCategory(subscribeRequest: SubscribeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscribeCategory(subscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 카테고리 구독을 취소합니다.
     * @summary 구독 취소
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsubscribeCategory(categoryId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsubscribeCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 저장한 북마크의 메모를 수정합니다.
     * @summary 북마크 메모 수정
     * @param {number} id 
     * @param {UpdateRequest} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateBookmarkMemo(id: number, updateRequest: UpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBookmarkMemo(id, updateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 푸시 알림을 위한 FCM 토큰을 업데이트합니다.
     * @summary FCM 토큰 업데이트
     * @param {UpdateFcmTokenRequest} updateFcmTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFcmToken(updateFcmTokenRequest: UpdateFcmTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateFcmToken(updateFcmTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 구독한 카테고리의 알림을 활성화하거나 비활성화합니다.
     * @summary 알림 설정 변경
     * @param {number} categoryId 
     * @param {UpdateNotificationRequest} updateNotificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateNotification(categoryId: number, updateNotificationRequest: UpdateNotificationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateNotification(categoryId, updateNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 이름 등 프로필 정보를 수정합니다.
     * @summary 프로필 수정
     * @param {UpdateProfileRequest} updateProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProfile(updateProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 다크 모드, 시스템 알림 등 사용자 설정을 변경합니다.
     * @summary 사용자 설정 수정
     * @param {UpdateSettingsRequest} updateSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSettings(updateSettingsRequest: UpdateSettingsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateSettings(updateSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 회원가입 시 발송된 이메일의 인증 링크로 이메일을 인증합니다.
     * @summary 이메일 인증
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



